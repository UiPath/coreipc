[assembly: System.Reflection.AssemblyMetadata("RepositoryUrl", "https://github.com/UiPath/coreipc.git")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Playground")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("UiPath.CoreIpc.BackCompat")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("UiPath.CoreIpc.Tests")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("UiPath.Ipc.TV")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("UiPath.Ipc.Tests")]
[assembly: System.Runtime.Versioning.SupportedOSPlatform("Windows7.0")]
[assembly: System.Runtime.Versioning.TargetFramework(".NETCoreApp,Version=v6.0", FrameworkDisplayName=".NET 6.0")]
[assembly: System.Runtime.Versioning.TargetPlatform("Windows7.0")]
namespace UiPath.Ipc
{
    public readonly struct CallInfo
    {
        public CallInfo(bool newConnection, System.Reflection.MethodInfo method, object?[] arguments) { }
        public object?[] Arguments { get; }
        public System.Reflection.MethodInfo Method { get; }
        public bool NewConnection { get; }
    }
    public sealed class ClientConfig : UiPath.Ipc.EndpointConfig, System.IEquatable<UiPath.Ipc.ClientConfig>
    {
        public ClientConfig() { }
        public string DebugName { get; set; }
        public UiPath.Ipc.ISerializer? Serializer { get; set; }
        public System.Func<UiPath.Ipc.CallInfo, System.Threading.CancellationToken, System.Threading.Tasks.Task>? BeforeCall { get; init; }
        public System.Func<System.Threading.CancellationToken, System.Threading.Tasks.Task>? BeforeConnect { get; init; }
        public UiPath.Ipc.EndpointCollection? Callbacks { get; init; }
        public Microsoft.Extensions.Logging.ILogger? Logger { get; init; }
        public System.Threading.Tasks.TaskScheduler? Scheduler { get; init; }
        public System.IServiceProvider? ServiceProvider { get; init; }
    }
    public abstract class ClientTransport : System.IEquatable<UiPath.Ipc.ClientTransport>
    {
        protected ClientTransport() { }
        public abstract UiPath.Ipc.IClientState CreateState();
        public abstract void Validate();
    }
    public class EndpointCollection : System.Collections.Generic.IEnumerable<UiPath.Ipc.EndpointSettings>, System.Collections.IEnumerable
    {
        public EndpointCollection() { }
        public void Add(System.Type type) { }
        public void Add(UiPath.Ipc.EndpointSettings endpointSettings) { }
        public void Add(System.Type contractType, object? instance) { }
        public System.Collections.Generic.IEnumerator<UiPath.Ipc.EndpointSettings> GetEnumerator() { }
    }
    public abstract class EndpointConfig : System.IEquatable<UiPath.Ipc.EndpointConfig>
    {
        protected EndpointConfig() { }
        public System.TimeSpan RequestTimeout { get; init; }
    }
    [System.Serializable]
    public sealed class EndpointNotFoundException : System.ArgumentOutOfRangeException
    {
        public EndpointNotFoundException(string paramName, string serverDebugName, string endpointName) { }
        public string EndpointName { get; }
        public string ServerDebugName { get; }
    }
    public class EndpointSettings : System.IEquatable<UiPath.Ipc.EndpointSettings>
    {
        public EndpointSettings(System.Type contractType, System.IServiceProvider serviceProvider) { }
        public EndpointSettings(System.Type contractType, object? serviceInstance = null) { }
        public System.Func<UiPath.Ipc.CallInfo, System.Threading.CancellationToken, System.Threading.Tasks.Task>? BeforeCall { get; set; }
        public System.Type ContractType { get; }
        public System.Threading.Tasks.TaskScheduler? Scheduler { get; set; }
        public object? ServiceInstance { get; }
        public System.IServiceProvider? ServiceProvider { get; }
        public void Validate() { }
        public virtual UiPath.Ipc.EndpointSettings WithServiceProvider(System.IServiceProvider? serviceProvider) { }
    }
    public sealed class EndpointSettings<TContract> : UiPath.Ipc.EndpointSettings, System.IEquatable<UiPath.Ipc.EndpointSettings<TContract>>
        where TContract :  class
    {
        public EndpointSettings(System.IServiceProvider serviceProvider) { }
        public EndpointSettings(TContract? serviceInstance = null) { }
        public override UiPath.Ipc.EndpointSettings WithServiceProvider(System.IServiceProvider? serviceProvider) { }
    }
    [System.Serializable]
    public class Error : System.IEquatable<UiPath.Ipc.Error>
    {
        public Error(string Message, string StackTrace, string Type, UiPath.Ipc.Error? InnerError) { }
        public UiPath.Ipc.Error? InnerError { get; init; }
        public string Message { get; init; }
        public string StackTrace { get; init; }
        public string Type { get; init; }
        public override string ToString() { }
        [return: System.Diagnostics.CodeAnalysis.NotNullIfNotNull("exception")]
        public static UiPath.Ipc.Error? FromException(System.Exception? exception) { }
    }
    public interface IClient
    {
        TCallbackInterface GetCallback<TCallbackInterface>()
            where TCallbackInterface :  class;
        void Impersonate(System.Action action);
    }
    public interface IClientState : System.IDisposable
    {
        System.IO.Stream? Network { get; }
        System.Threading.Tasks.ValueTask Connect(UiPath.Ipc.IpcClient client, System.Threading.CancellationToken ct);
        bool IsConnected();
    }
    public static class IOHelpers
    {
        public static System.IO.Pipes.PipeSecurity Allow(this System.IO.Pipes.PipeSecurity pipeSecurity, System.Security.Principal.IdentityReference sid, System.IO.Pipes.PipeAccessRights pipeAccessRights) { }
        public static System.IO.Pipes.PipeSecurity Allow(this System.IO.Pipes.PipeSecurity pipeSecurity, System.Security.Principal.WellKnownSidType sid, System.IO.Pipes.PipeAccessRights pipeAccessRights) { }
        public static System.IO.Pipes.PipeSecurity AllowCurrentUser(this System.IO.Pipes.PipeSecurity pipeSecurity, bool onlyNonAdmin = false) { }
        public static System.IO.Pipes.PipeSecurity Deny(this System.IO.Pipes.PipeSecurity pipeSecurity, System.Security.Principal.IdentityReference sid, System.IO.Pipes.PipeAccessRights pipeAccessRights) { }
        public static System.IO.Pipes.PipeSecurity Deny(this System.IO.Pipes.PipeSecurity pipeSecurity, System.Security.Principal.WellKnownSidType sid, System.IO.Pipes.PipeAccessRights pipeAccessRights) { }
        public static System.IO.Pipes.PipeSecurity LocalOnly(this System.IO.Pipes.PipeSecurity pipeSecurity) { }
        public static bool PipeExists(string pipeName, int timeout = 1) { }
    }
    public interface ISerializer
    {
        object? Deserialize(string json, System.Type type);
        System.Threading.Tasks.ValueTask<T?> DeserializeAsync<T>(System.IO.Stream json, Microsoft.Extensions.Logging.ILogger? logger);
        string Serialize(object? obj);
        void Serialize(object? obj, System.IO.Stream stream);
    }
    public sealed class IpcClient
    {
        [System.Obsolete("Constructors of types with required members are not supported in this version of " +
            "your compiler.", true)]
        public IpcClient() { }
        public UiPath.Ipc.ClientConfig Config { get; init; }
        public UiPath.Ipc.ClientTransport Transport { get; init; }
        public TProxy GetProxy<TProxy>()
            where TProxy :  class { }
    }
    public class IpcProxy : System.Reflection.DispatchProxy, System.IDisposable
    {
        public IpcProxy() { }
        public System.IO.Stream? Network { get; }
        public event System.EventHandler ConnectionClosed;
        public System.Threading.Tasks.ValueTask CloseConnection() { }
        public void Dispose() { }
        protected override object? Invoke(System.Reflection.MethodInfo? targetMethod, object?[]? args) { }
    }
    public sealed class IpcServer : System.IAsyncDisposable
    {
        [System.Obsolete("Constructors of types with required members are not supported in this version of " +
            "your compiler.", true)]
        public IpcServer() { }
        public UiPath.Ipc.EndpointCollection Endpoints { get; init; }
        public System.Collections.Generic.IReadOnlyList<UiPath.Ipc.ListenerConfig> Listeners { get; init; }
        public System.Threading.Tasks.TaskScheduler? Scheduler { get; init; }
        public System.IServiceProvider ServiceProvider { get; init; }
        public System.Threading.Tasks.ValueTask DisposeAsync() { }
        public void Start() { }
        public System.Threading.Tasks.Task WaitForStart() { }
        public System.Threading.Tasks.Task WaitForStop() { }
    }
    public abstract class ListenerConfig : UiPath.Ipc.EndpointConfig, System.IEquatable<UiPath.Ipc.ListenerConfig>
    {
        protected ListenerConfig() { }
        public System.Security.Cryptography.X509Certificates.X509Certificate? Certificate { get; init; }
        public int ConcurrentAccepts { get; init; }
        public byte MaxReceivedMessageSizeInMegabytes { get; init; }
    }
    public class Message
    {
        public Message() { }
        [Newtonsoft.Json.JsonIgnore]
        public UiPath.Ipc.IClient Client { get; set; }
        [Newtonsoft.Json.JsonIgnore]
        public System.TimeSpan RequestTimeout { get; set; }
        public TCallbackInterface GetCallback<TCallbackInterface>()
            where TCallbackInterface :  class { }
        public void ImpersonateClient(System.Action action) { }
    }
    public class Message<TPayload> : UiPath.Ipc.Message
    {
        public Message(TPayload payload) { }
        public TPayload Payload { get; }
    }
    [System.Serializable]
    public class RemoteException : System.Exception
    {
        public RemoteException(UiPath.Ipc.Error error) { }
        public UiPath.Ipc.RemoteException? InnerException { get; }
        public override string StackTrace { get; }
        public string Type { get; }
        public bool Is<TException>()
            where TException : System.Exception { }
        public override string ToString() { }
    }
}
namespace UiPath.Ipc.Extensibility
{
    public interface IListenerConfig<TSelf, TListenerState, TConnectionState>
        where TSelf : UiPath.Ipc.ListenerConfig, UiPath.Ipc.Extensibility.IListenerConfig<TSelf, TListenerState, TConnectionState>
        where TListenerState : System.IAsyncDisposable
    {
        System.Threading.Tasks.ValueTask<System.IO.Stream> AwaitConnection(TListenerState listenerState, TConnectionState connectionState, System.Threading.CancellationToken ct);
        TConnectionState CreateConnectionState(UiPath.Ipc.IpcServer server, TListenerState listenerState);
        TListenerState CreateListenerState(UiPath.Ipc.IpcServer server);
        System.Collections.Generic.IEnumerable<string> Validate();
    }
}
namespace UiPath.Ipc.Transport.NamedPipe
{
    public sealed class NamedPipeListener : UiPath.Ipc.ListenerConfig, System.IEquatable<UiPath.Ipc.Transport.NamedPipe.NamedPipeListener>, UiPath.Ipc.Extensibility.IListenerConfig<UiPath.Ipc.Transport.NamedPipe.NamedPipeListener, UiPath.Ipc.Transport.NamedPipe.NamedPipeListenerState, UiPath.Ipc.Transport.NamedPipe.NamedPipeServerConnectionState>
    {
        [System.Obsolete("Constructors of types with required members are not supported in this version of " +
            "your compiler.", true)]
        public NamedPipeListener() { }
        [Newtonsoft.Json.JsonIgnore]
        public System.Action<System.IO.Pipes.PipeSecurity>? AccessControl { get; init; }
        public string PipeName { get; init; }
        public string ServerName { get; init; }
        public override string ToString() { }
    }
    public sealed class NamedPipeTransport : UiPath.Ipc.ClientTransport, System.IEquatable<UiPath.Ipc.Transport.NamedPipe.NamedPipeTransport>
    {
        [System.Obsolete("Constructors of types with required members are not supported in this version of " +
            "your compiler.", true)]
        public NamedPipeTransport() { }
        public bool AllowImpersonation { get; init; }
        public string PipeName { get; init; }
        public string ServerName { get; init; }
        public override UiPath.Ipc.IClientState CreateState() { }
        public override string ToString() { }
        public override void Validate() { }
    }
}
namespace UiPath.Ipc.Transport.Tcp
{
    public sealed class TcpListener : UiPath.Ipc.ListenerConfig, System.IEquatable<UiPath.Ipc.Transport.Tcp.TcpListener>, UiPath.Ipc.Extensibility.IListenerConfig<UiPath.Ipc.Transport.Tcp.TcpListener, UiPath.Ipc.Transport.Tcp.TcpListenerState, UiPath.Ipc.Transport.Tcp.TcpServerConnectionState>
    {
        [System.Obsolete("Constructors of types with required members are not supported in this version of " +
            "your compiler.", true)]
        public TcpListener() { }
        public System.Net.IPEndPoint EndPoint { get; init; }
        public override string ToString() { }
    }
    public sealed class TcpTransport : UiPath.Ipc.ClientTransport, System.IEquatable<UiPath.Ipc.Transport.Tcp.TcpTransport>
    {
        [System.Obsolete("Constructors of types with required members are not supported in this version of " +
            "your compiler.", true)]
        public TcpTransport() { }
        public System.Net.IPEndPoint EndPoint { get; init; }
        public override UiPath.Ipc.IClientState CreateState() { }
        public override string ToString() { }
        public override void Validate() { }
    }
}
namespace UiPath.Ipc.Transport.WebSocket
{
    public sealed class WebSocketListener : UiPath.Ipc.ListenerConfig, System.IEquatable<UiPath.Ipc.Transport.WebSocket.WebSocketListener>, UiPath.Ipc.Extensibility.IListenerConfig<UiPath.Ipc.Transport.WebSocket.WebSocketListener, UiPath.Ipc.Transport.WebSocket.WebSocketListenerState, UiPath.Ipc.Transport.WebSocket.WebSocketServerConnectionState>
    {
        [System.Obsolete("Constructors of types with required members are not supported in this version of " +
            "your compiler.", true)]
        public WebSocketListener() { }
        public System.Func<System.Threading.CancellationToken, System.Threading.Tasks.Task<System.Net.WebSockets.WebSocket>> Accept { get; init; }
        public override string ToString() { }
    }
    public sealed class WebSocketTransport : UiPath.Ipc.ClientTransport, System.IEquatable<UiPath.Ipc.Transport.WebSocket.WebSocketTransport>
    {
        [System.Obsolete("Constructors of types with required members are not supported in this version of " +
            "your compiler.", true)]
        public WebSocketTransport() { }
        public System.Uri Uri { get; init; }
        public override UiPath.Ipc.IClientState CreateState() { }
        public override string ToString() { }
        public override void Validate() { }
    }
}