[assembly: System.Reflection.AssemblyMetadata("RepositoryUrl", "https://github.com/UiPath/coreipc.git")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Playground")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("UiPath.CoreIpc.BackCompat")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("UiPath.CoreIpc.Tests")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("UiPath.Ipc.TV")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("UiPath.Ipc.Tests")]
[assembly: System.Runtime.Versioning.SupportedOSPlatform("Windows7.0")]
[assembly: System.Runtime.Versioning.TargetFramework(".NETCoreApp,Version=v6.0", FrameworkDisplayName=".NET 6.0")]
[assembly: System.Runtime.Versioning.TargetPlatform("Windows7.0")]
namespace UiPath.Ipc
{
    public readonly struct CallInfo
    {
        public CallInfo(bool newConnection, System.Reflection.MethodInfo method, object?[] arguments) { }
        public object?[] Arguments { get; }
        public System.Reflection.MethodInfo Method { get; }
        public bool NewConnection { get; }
    }
    public abstract class ClientTransport : System.IEquatable<UiPath.Ipc.ClientTransport>
    {
        protected ClientTransport() { }
        public abstract UiPath.Ipc.IClientState CreateState();
        public abstract void Validate();
    }
    public class EndpointCollection : System.Collections.Generic.IEnumerable<UiPath.Ipc.EndpointSettings>, System.Collections.IEnumerable
    {
        public EndpointCollection() { }
        public void Add(System.Type type) { }
        public void Add(UiPath.Ipc.EndpointSettings endpointSettings) { }
        public void Add(System.Type contractType, object? instance) { }
        public System.Collections.Generic.IEnumerator<UiPath.Ipc.EndpointSettings> GetEnumerator() { }
    }
    [System.Serializable]
    public sealed class EndpointNotFoundException : System.ArgumentOutOfRangeException
    {
        public EndpointNotFoundException(string paramName, string serverDebugName, string endpointName) { }
        public string EndpointName { get; }
        public string ServerDebugName { get; }
    }
    public class EndpointSettings : System.IEquatable<UiPath.Ipc.EndpointSettings>
    {
        public EndpointSettings(System.Type contractType, System.IServiceProvider serviceProvider) { }
        public EndpointSettings(System.Type contractType, object? serviceInstance = null) { }
        public System.Func<UiPath.Ipc.CallInfo, System.Threading.CancellationToken, System.Threading.Tasks.Task>? BeforeIncommingCall { get; set; }
        public System.Type ContractType { get; }
        public System.Threading.Tasks.TaskScheduler? Scheduler { get; set; }
        public object? ServiceInstance { get; }
        public System.IServiceProvider? ServiceProvider { get; }
        public void Validate() { }
        public virtual UiPath.Ipc.EndpointSettings WithServiceProvider(System.IServiceProvider? serviceProvider) { }
    }
    public sealed class EndpointSettings<TContract> : UiPath.Ipc.EndpointSettings, System.IEquatable<UiPath.Ipc.EndpointSettings<TContract>>
        where TContract :  class
    {
        public EndpointSettings(System.IServiceProvider serviceProvider) { }
        public EndpointSettings(TContract? serviceInstance = null) { }
        public override UiPath.Ipc.EndpointSettings WithServiceProvider(System.IServiceProvider? serviceProvider) { }
    }
    [System.Serializable]
    public class Error : System.IEquatable<UiPath.Ipc.Error>
    {
        public Error(string Message, string StackTrace, string Type, UiPath.Ipc.Error? InnerError) { }
        public UiPath.Ipc.Error? InnerError { get; init; }
        public string Message { get; init; }
        public string StackTrace { get; init; }
        public string Type { get; init; }
        public override string ToString() { }
        [return: System.Diagnostics.CodeAnalysis.NotNullIfNotNull("exception")]
        public static UiPath.Ipc.Error? FromException(System.Exception? exception) { }
    }
    public interface IClient
    {
        TCallbackInterface GetCallback<TCallbackInterface>()
            where TCallbackInterface :  class;
        void Impersonate(System.Action action);
    }
    public interface IClientState : System.IDisposable
    {
        System.IO.Stream? Network { get; }
        System.Threading.Tasks.ValueTask Connect(UiPath.Ipc.IpcClient client, System.Threading.CancellationToken ct);
        bool IsConnected();
    }
    public static class IOHelpers
    {
        public static System.IO.Pipes.PipeSecurity Allow(this System.IO.Pipes.PipeSecurity pipeSecurity, System.Security.Principal.IdentityReference sid, System.IO.Pipes.PipeAccessRights pipeAccessRights) { }
        public static System.IO.Pipes.PipeSecurity Allow(this System.IO.Pipes.PipeSecurity pipeSecurity, System.Security.Principal.WellKnownSidType sid, System.IO.Pipes.PipeAccessRights pipeAccessRights) { }
        public static System.IO.Pipes.PipeSecurity AllowCurrentUser(this System.IO.Pipes.PipeSecurity pipeSecurity, bool onlyNonAdmin = false) { }
        public static System.IO.Pipes.PipeSecurity Deny(this System.IO.Pipes.PipeSecurity pipeSecurity, System.Security.Principal.IdentityReference sid, System.IO.Pipes.PipeAccessRights pipeAccessRights) { }
        public static System.IO.Pipes.PipeSecurity Deny(this System.IO.Pipes.PipeSecurity pipeSecurity, System.Security.Principal.WellKnownSidType sid, System.IO.Pipes.PipeAccessRights pipeAccessRights) { }
        public static System.IO.Pipes.PipeSecurity LocalOnly(this System.IO.Pipes.PipeSecurity pipeSecurity) { }
        public static bool PipeExists(string pipeName, int timeout = 1) { }
    }
    public sealed class IpcClient : UiPath.Ipc.Peer
    {
        [System.Obsolete("Constructors of types with required members are not supported in this version of " +
            "your compiler.", true)]
        public IpcClient() { }
        public System.Func<System.Threading.CancellationToken, System.Threading.Tasks.Task>? BeforeConnect { get; set; }
        public System.Func<UiPath.Ipc.CallInfo, System.Threading.CancellationToken, System.Threading.Tasks.Task>? BeforeOutgoingCall { get; set; }
        public UiPath.Ipc.EndpointCollection? Callbacks { get; set; }
        public string DebugName { get; set; }
        public Microsoft.Extensions.Logging.ILogger? Logger { get; init; }
        public UiPath.Ipc.ClientTransport Transport { get; init; }
        public TProxy GetProxy<TProxy>()
            where TProxy :  class { }
    }
    public class IpcProxy : System.Reflection.DispatchProxy, System.IDisposable
    {
        public IpcProxy() { }
        public System.IO.Stream? Network { get; }
        public event System.EventHandler ConnectionClosed;
        public System.Threading.Tasks.ValueTask CloseConnection() { }
        public void Dispose() { }
        protected override object? Invoke(System.Reflection.MethodInfo? targetMethod, object?[]? args) { }
    }
    public sealed class IpcServer : UiPath.Ipc.Peer, System.IAsyncDisposable
    {
        [System.Obsolete("Constructors of types with required members are not supported in this version of " +
            "your compiler.", true)]
        public IpcServer() { }
        public UiPath.Ipc.EndpointCollection Endpoints { get; init; }
        public UiPath.Ipc.ServerTransport Transport { get; init; }
        public System.Threading.Tasks.ValueTask DisposeAsync() { }
        [System.Diagnostics.CodeAnalysis.MemberNotNull(new string[] {
                "Transport",
                "_accepter"})]
        public void Start() { }
        public System.Threading.Tasks.Task WaitForStart() { }
        public System.Threading.Tasks.Task WaitForStop() { }
    }
    public class Message
    {
        public Message() { }
        [Newtonsoft.Json.JsonIgnore]
        public UiPath.Ipc.IClient Client { get; set; }
        [Newtonsoft.Json.JsonIgnore]
        public System.TimeSpan RequestTimeout { get; set; }
        public TCallbackInterface GetCallback<TCallbackInterface>()
            where TCallbackInterface :  class { }
        public void ImpersonateClient(System.Action action) { }
    }
    public class Message<TPayload> : UiPath.Ipc.Message
    {
        public Message(TPayload payload) { }
        public TPayload Payload { get; }
    }
    public abstract class Peer
    {
        protected Peer() { }
        public System.TimeSpan RequestTimeout { get; set; }
        public System.Threading.Tasks.TaskScheduler? Scheduler { get; set; }
        public System.IServiceProvider? ServiceProvider { get; set; }
    }
    [System.Serializable]
    public class RemoteException : System.Exception
    {
        public RemoteException(UiPath.Ipc.Error error) { }
        public UiPath.Ipc.RemoteException? InnerException { get; }
        public override string StackTrace { get; }
        public string Type { get; }
        public bool Is<TException>()
            where TException : System.Exception { }
        public override string ToString() { }
    }
    public abstract class ServerTransport
    {
        protected ServerTransport() { }
        public int ConcurrentAccepts { get; set; }
        public byte MaxReceivedMessageSizeInMegabytes { get; set; }
        public System.Security.Cryptography.X509Certificates.X509Certificate? Certificate { get; init; }
        protected abstract UiPath.Ipc.ServerTransport.IServerState CreateServerState();
        protected abstract System.Collections.Generic.IEnumerable<string?> ValidateCore();
        protected static string? IsNotNull<T>(T? propertyValue, [System.Runtime.CompilerServices.CallerArgumentExpression("propertyValue")] string? propertyName = null) { }
        protected interface IServerConnectionSlot : System.IDisposable
        {
            System.Threading.Tasks.ValueTask<System.IO.Stream> AwaitConnection(System.Threading.CancellationToken ct);
        }
        protected interface IServerState : System.IAsyncDisposable
        {
            UiPath.Ipc.ServerTransport.IServerConnectionSlot CreateConnectionSlot();
        }
    }
}
namespace UiPath.Ipc.Transport.NamedPipe
{
    public sealed class NamedPipeClientTransport : UiPath.Ipc.ClientTransport, System.IEquatable<UiPath.Ipc.Transport.NamedPipe.NamedPipeClientTransport>
    {
        [System.Obsolete("Constructors of types with required members are not supported in this version of " +
            "your compiler.", true)]
        public NamedPipeClientTransport() { }
        public bool AllowImpersonation { get; init; }
        public string PipeName { get; init; }
        public string ServerName { get; init; }
        public override UiPath.Ipc.IClientState CreateState() { }
        public override string ToString() { }
        public override void Validate() { }
    }
    public sealed class NamedPipeServerTransport : UiPath.Ipc.ServerTransport
    {
        [System.Obsolete("Constructors of types with required members are not supported in this version of " +
            "your compiler.", true)]
        public NamedPipeServerTransport() { }
        [Newtonsoft.Json.JsonIgnore]
        public System.Action<System.IO.Pipes.PipeSecurity>? AccessControl { get; init; }
        public string PipeName { get; init; }
        public string ServerName { get; init; }
        protected override UiPath.Ipc.ServerTransport.IServerState CreateServerState() { }
        public override string ToString() { }
        protected override System.Collections.Generic.IEnumerable<string?> ValidateCore() { }
    }
}
namespace UiPath.Ipc.Transport.Tcp
{
    public sealed class TcpClientTransport : UiPath.Ipc.ClientTransport, System.IEquatable<UiPath.Ipc.Transport.Tcp.TcpClientTransport>
    {
        [System.Obsolete("Constructors of types with required members are not supported in this version of " +
            "your compiler.", true)]
        public TcpClientTransport() { }
        public System.Net.IPEndPoint EndPoint { get; init; }
        public override UiPath.Ipc.IClientState CreateState() { }
        public override string ToString() { }
        public override void Validate() { }
    }
    public sealed class TcpServerTransport : UiPath.Ipc.ServerTransport
    {
        [System.Obsolete("Constructors of types with required members are not supported in this version of " +
            "your compiler.", true)]
        public TcpServerTransport() { }
        public System.Net.IPEndPoint EndPoint { get; init; }
        protected override UiPath.Ipc.ServerTransport.IServerState CreateServerState() { }
        public override string ToString() { }
        protected override System.Collections.Generic.IEnumerable<string?> ValidateCore() { }
    }
}
namespace UiPath.Ipc.Transport.WebSocket
{
    public sealed class WebSocketClientTransport : UiPath.Ipc.ClientTransport, System.IEquatable<UiPath.Ipc.Transport.WebSocket.WebSocketClientTransport>
    {
        [System.Obsolete("Constructors of types with required members are not supported in this version of " +
            "your compiler.", true)]
        public WebSocketClientTransport() { }
        public System.Uri Uri { get; init; }
        public override UiPath.Ipc.IClientState CreateState() { }
        public override string ToString() { }
        public override void Validate() { }
    }
    public sealed class WebSocketServerTransport : UiPath.Ipc.ServerTransport, System.IAsyncDisposable, System.IDisposable, UiPath.Ipc.ServerTransport.IServerConnectionSlot, UiPath.Ipc.ServerTransport.IServerState
    {
        [System.Obsolete("Constructors of types with required members are not supported in this version of " +
            "your compiler.", true)]
        public WebSocketServerTransport() { }
        public System.Func<System.Threading.CancellationToken, System.Threading.Tasks.Task<System.Net.WebSockets.WebSocket>> Accept { get; init; }
        protected override UiPath.Ipc.ServerTransport.IServerState CreateServerState() { }
        public override string ToString() { }
        protected override System.Collections.Generic.IEnumerable<string?> ValidateCore() { }
    }
}