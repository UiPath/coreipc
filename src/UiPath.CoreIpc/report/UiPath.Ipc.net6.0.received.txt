[assembly: System.Reflection.AssemblyMetadata("RepositoryUrl", "https://github.com/UiPath/coreipc.git")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Playground")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("UiPath.CoreIpc.Tests")]
[assembly: System.Runtime.Versioning.TargetFramework(".NETCoreApp,Version=v6.0", FrameworkDisplayName=".NET 6.0")]
namespace UiPath.Ipc
{
    public readonly struct CallInfo
    {
        public CallInfo(bool newConnection, System.Reflection.MethodInfo method, object?[] arguments) { }
        public object?[] Arguments { get; }
        public System.Reflection.MethodInfo Method { get; }
        public bool NewConnection { get; }
    }
    public sealed class Connection : System.IDisposable
    {
        public Connection(System.IO.Stream network, UiPath.Ipc.ISerializer? serializer, Microsoft.Extensions.Logging.ILogger? logger, string debugName, int maxMessageSize = 2147483647) { }
        public string DebugName { get; }
        [System.Diagnostics.CodeAnalysis.MemberNotNullWhen(true, "Logger")]
        [get: System.Diagnostics.CodeAnalysis.MemberNotNullWhen(true, "Logger")]
        public bool LogEnabled { get; }
        public Microsoft.Extensions.Logging.ILogger? Logger { get; }
        public System.IO.Stream Network { get; }
        public UiPath.Ipc.ISerializer? Serializer { get; }
        public event System.EventHandler<System.EventArgs> Closed;
        public void Dispose() { }
        public System.Threading.Tasks.Task Listen() { }
        public string NewRequestId() { }
        public override string ToString() { }
    }
    public sealed class ConnectionConfig : UiPath.Ipc.EndpointConfig, System.IEquatable<UiPath.Ipc.ConnectionConfig>
    {
        public ConnectionConfig() { }
        public System.Func<UiPath.Ipc.CallInfo, System.Threading.CancellationToken, System.Threading.Tasks.Task>? BeforeCall { get; init; }
        public UiPath.Ipc.EndpointCollection? Callbacks { get; init; }
        public System.Func<UiPath.Ipc.Connection?, System.Threading.CancellationToken, System.Threading.Tasks.Task<UiPath.Ipc.Connection>>? ConnectionFactory { get; init; }
        public Microsoft.Extensions.Logging.ILogger? Logger { get; init; }
        public System.Threading.Tasks.TaskScheduler? Scheduler { get; init; }
        public System.IServiceProvider? ServiceProvider { get; init; }
        public void Validate() { }
    }
    public abstract class ConnectionKey : System.IEquatable<UiPath.Ipc.ConnectionKey>
    {
        protected ConnectionKey() { }
    }
    public class EndpointCollection : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.Type, object?>>, System.Collections.IEnumerable
    {
        public EndpointCollection() { }
        public void Add(System.Type type) { }
        public void Add(System.Type type, object? instance) { }
        public void Add<T>(T instance)
            where T :  class { }
        public System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<System.Type, object?>> GetEnumerator() { }
    }
    public abstract class EndpointConfig : System.IEquatable<UiPath.Ipc.EndpointConfig>
    {
        protected EndpointConfig() { }
        public System.TimeSpan RequestTimeout { get; init; }
    }
    public class EndpointSettings
    {
        public EndpointSettings(System.Type contractType, System.IServiceProvider serviceProvider) { }
        public EndpointSettings(System.Type contractType, object? serviceInstance) { }
        public System.Func<UiPath.Ipc.CallInfo, System.Threading.CancellationToken, System.Threading.Tasks.Task>? BeforeCall { get; set; }
        public void Validate() { }
    }
    public class EndpointSettings<TContract> : UiPath.Ipc.EndpointSettings
        where TContract :  class
    {
        public EndpointSettings(System.IServiceProvider serviceProvider) { }
        public EndpointSettings(TContract? serviceInstance = null) { }
    }
    [System.Serializable]
    public class Error : System.IEquatable<UiPath.Ipc.Error>
    {
        public Error(string Message, string StackTrace, string Type, UiPath.Ipc.Error? InnerError) { }
        public UiPath.Ipc.Error? InnerError { get; init; }
        public string Message { get; init; }
        public string StackTrace { get; init; }
        public string Type { get; init; }
        public override string ToString() { }
        [return: System.Diagnostics.CodeAnalysis.NotNullIfNotNull("exception")]
        public static UiPath.Ipc.Error? FromException(System.Exception? exception) { }
    }
    public static class Helpers { }
    public interface IClient
    {
        TCallbackInterface GetCallback<TCallbackInterface>()
            where TCallbackInterface :  class;
        void Impersonate(System.Action action);
    }
    public static class IOHelpers
    {
        public static System.IO.Pipes.PipeSecurity Allow(this System.IO.Pipes.PipeSecurity pipeSecurity, System.Security.Principal.IdentityReference sid, System.IO.Pipes.PipeAccessRights pipeAccessRights) { }
        public static System.IO.Pipes.PipeSecurity Allow(this System.IO.Pipes.PipeSecurity pipeSecurity, System.Security.Principal.WellKnownSidType sid, System.IO.Pipes.PipeAccessRights pipeAccessRights) { }
        public static System.IO.Pipes.PipeSecurity AllowCurrentUser(this System.IO.Pipes.PipeSecurity pipeSecurity, bool onlyNonAdmin = false) { }
        public static System.IO.Pipes.PipeSecurity Deny(this System.IO.Pipes.PipeSecurity pipeSecurity, System.Security.Principal.IdentityReference sid, System.IO.Pipes.PipeAccessRights pipeAccessRights) { }
        public static System.IO.Pipes.PipeSecurity Deny(this System.IO.Pipes.PipeSecurity pipeSecurity, System.Security.Principal.WellKnownSidType sid, System.IO.Pipes.PipeAccessRights pipeAccessRights) { }
        public static System.IO.Pipes.PipeSecurity LocalOnly(this System.IO.Pipes.PipeSecurity pipeSecurity) { }
        public static bool PipeExists(string pipeName, int timeout = 1) { }
    }
    public interface ISerializer
    {
        object? Deserialize(string json, System.Type type);
        System.Threading.Tasks.ValueTask<T?> DeserializeAsync<T>(System.IO.Stream json);
        string Serialize(object? obj);
        void Serialize(object? obj, System.IO.Stream stream);
    }
    public static class IpcClient
    {
        public static void Config(UiPath.Ipc.ConnectionKey key, UiPath.Ipc.ConnectionConfig config) { }
        public static T Connect<T>(UiPath.Ipc.ConnectionKey key)
            where T :  class { }
    }
    public class IpcProxy : System.Reflection.DispatchProxy, System.IDisposable
    {
        public IpcProxy() { }
        public UiPath.Ipc.Connection? Connection { get; }
        public void CloseConnection() { }
        public void Dispose() { }
        protected override object? Invoke(System.Reflection.MethodInfo? targetMethod, object?[]? args) { }
    }
    public sealed class IpcServer : System.IAsyncDisposable
    {
        [System.Obsolete("Constructors of types with required members are not supported in this version of " +
            "your compiler.", true)]
        public IpcServer() { }
        public UiPath.Ipc.IpcServerConfig Config { get; init; }
        public System.Threading.Tasks.ValueTask DisposeAsync() { }
        public void EnsureStarted() { }
    }
    public readonly struct IpcServerConfig : System.IEquatable<UiPath.Ipc.IpcServerConfig>
    {
        public System.Collections.Generic.IReadOnlyList<System.Type>? Callbacks { get; init; }
        public UiPath.Ipc.EndpointCollection Endpoints { get; init; }
        public System.Collections.Generic.IReadOnlyList<UiPath.Ipc.ListenerConfig> Listeners { get; init; }
        public System.Threading.Tasks.TaskScheduler? Scheduler { get; init; }
        public System.IServiceProvider ServiceProvider { get; init; }
    }
    public abstract class ListenerConfig : UiPath.Ipc.EndpointConfig, System.IEquatable<UiPath.Ipc.ListenerConfig>
    {
        protected ListenerConfig() { }
        public System.Security.Cryptography.X509Certificates.X509Certificate? Certificate { get; init; }
        public int ConcurrentAccepts { get; init; }
        public byte MaxReceivedMessageSizeInMegabytes { get; init; }
        public abstract System.IAsyncDisposable CreateListener(UiPath.Ipc.IpcServer server);
        protected abstract System.Collections.Generic.IEnumerable<string> Validate();
    }
    public abstract class ListenerId : System.IEquatable<UiPath.Ipc.ListenerId>
    {
        protected ListenerId() { }
    }
    public abstract class ListenerId<TTransport> : UiPath.Ipc.ListenerId, System.IEquatable<UiPath.Ipc.ListenerId<TTransport>>
    {
        protected ListenerId() { }
    }
    public class Message
    {
        public Message() { }
        [Newtonsoft.Json.JsonIgnore]
        public UiPath.Ipc.IClient Client { get; set; }
        [Newtonsoft.Json.JsonIgnore]
        public System.TimeSpan RequestTimeout { get; set; }
        public TCallbackInterface GetCallback<TCallbackInterface>()
            where TCallbackInterface :  class { }
        public void ImpersonateClient(System.Action action) { }
    }
    public class Message<TPayload> : UiPath.Ipc.Message
    {
        public Message(TPayload payload) { }
        public TPayload Payload { get; }
    }
    public sealed class NamedPipeConnectionKey : UiPath.Ipc.ConnectionKey, System.IEquatable<UiPath.Ipc.NamedPipeConnectionKey>
    {
        public NamedPipeConnectionKey(string pipeName, string serverName = ".", bool allowImpersonation = false) { }
        public bool AllowImpersonation { get; }
        public string PipeName { get; }
        public string ServerName { get; }
    }
    public sealed class NamedPipeListenerConfig : UiPath.Ipc.ListenerConfig, System.IEquatable<UiPath.Ipc.NamedPipeListenerConfig>
    {
        [System.Obsolete("Constructors of types with required members are not supported in this version of " +
            "your compiler.", true)]
        public NamedPipeListenerConfig() { }
        public System.Action<System.IO.Pipes.PipeSecurity>? AccessControl { get; init; }
        public string PipeName { get; init; }
        public string ServerName { get; init; }
        public override System.IAsyncDisposable CreateListener(UiPath.Ipc.IpcServer server) { }
        protected override System.Collections.Generic.IEnumerable<string> Validate() { }
    }
    public sealed class NamedPipeListenerId : UiPath.Ipc.ListenerId<UiPath.Ipc.NamedPipeListenerId.Transport>, System.IEquatable<UiPath.Ipc.NamedPipeListenerId>
    {
        public NamedPipeListenerId(string pipeName) { }
        public string PipeName { get; }
        public sealed class Transport : System.IEquatable<UiPath.Ipc.NamedPipeListenerId.Transport>
        {
            public Transport() { }
            public System.Action<System.IO.Pipes.PipeSecurity>? PipeSecurity { get; init; }
        }
    }
    [System.Serializable]
    public class RemoteException : System.Exception
    {
        public RemoteException(UiPath.Ipc.Error error) { }
        public UiPath.Ipc.RemoteException? InnerException { get; }
        public override string StackTrace { get; }
        public string Type { get; }
        public bool Is<TException>()
            where TException : System.Exception { }
        public override string ToString() { }
    }
    public sealed class TCPListenerId : UiPath.Ipc.ListenerId, System.IEquatable<UiPath.Ipc.TCPListenerId>
    {
        public TCPListenerId(System.Net.IPEndPoint endPoint) { }
        public System.Net.IPEndPoint EndPoint { get; }
    }
    public sealed class TcpConnectionKey : UiPath.Ipc.ConnectionKey, System.IEquatable<UiPath.Ipc.TcpConnectionKey>
    {
        public TcpConnectionKey(System.Net.IPEndPoint endPoint) { }
        public System.Net.IPEndPoint EndPoint { get; }
    }
    public sealed class TcpListenerConfig : UiPath.Ipc.ListenerConfig, System.IEquatable<UiPath.Ipc.TcpListenerConfig>
    {
        [System.Obsolete("Constructors of types with required members are not supported in this version of " +
            "your compiler.", true)]
        public TcpListenerConfig() { }
        public System.Net.IPEndPoint EndPoint { get; init; }
        public override System.IAsyncDisposable CreateListener(UiPath.Ipc.IpcServer server) { }
        protected override System.Collections.Generic.IEnumerable<string> Validate() { }
    }
    public sealed class WebSocketConnectionKey : UiPath.Ipc.ConnectionKey, System.IEquatable<UiPath.Ipc.WebSocketConnectionKey>
    {
        public WebSocketConnectionKey(System.Uri uri) { }
        public System.Uri Uri { get; }
    }
    public sealed class WebSocketListenerConfig : UiPath.Ipc.ListenerConfig, System.IEquatable<UiPath.Ipc.WebSocketListenerConfig>
    {
        [System.Obsolete("Constructors of types with required members are not supported in this version of " +
            "your compiler.", true)]
        public WebSocketListenerConfig() { }
        public System.Func<System.Threading.CancellationToken, System.Threading.Tasks.Task<System.Net.WebSockets.WebSocket>> Accept { get; init; }
        public override System.IAsyncDisposable CreateListener(UiPath.Ipc.IpcServer server) { }
        protected override System.Collections.Generic.IEnumerable<string> Validate() { }
    }
    public sealed class WebSocketListenerId : UiPath.Ipc.ListenerId, System.IEquatable<UiPath.Ipc.WebSocketListenerId>
    {
        [System.Obsolete("Constructors of types with required members are not supported in this version of " +
            "your compiler.", true)]
        public WebSocketListenerId(int port) { }
        public int Port { get; }
        public System.Func<System.Threading.CancellationToken, System.Threading.Tasks.Task<System.Net.WebSockets.WebSocket>> Accept { get; init; }
        public bool Equals(UiPath.Ipc.WebSocketListenerId? other) { }
        public override int GetHashCode() { }
    }
}